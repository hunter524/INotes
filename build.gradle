//apply plugin: 'java'
//plugins 语句块需要放在build.gradle的顶部第一行(可以替代apply plugin:'java' 语句


buildscript{
    println "I am Build script!"
}

//tips:只有buildScript 和 plugins 语句块自己能处于plugins之前
plugins{
//    id 'java'
//    id 'org.gradle.java'
    id 'base'
    id 'org.gradle.java'
}
println 'This is executed during the configuration phase.'

//通过该种方式才能引入对其他的 ****.gradle文件对额引用
//一个项目只能有一个 build.gradle 获取 <ProjectName>.gradle
apply from: "./deps.gradle"

//定义默认的task直接使用gradle 命令即可以执行
//gradle 带task参数时执行指定参数的Task 不带task参数时则执行默认的task
// defaultTasks 'DefaultTask1','DefaultTask2'

task DefaultTask1{
    doFirst{
        println "DefaultTask1 doFirst"
    }
}

task DefaultTask2{
    doFirst{
        println "DefaultTask2 doFirst!"
    }
}

task configured {
    println 'This is also executed during the configuration phase.'
}

//task test {
//
//    doLast{
//        println 'This is executed during the execution phase.'
//    }
//}

task testBoth {
    doFirst {
      println 'This is executed first during the execution phase.'
    }
    doLast {
      println 'This is executed last during the execution phase.'
    }
    println 'This is executed during the configuration phase as well.'
}

//没有Action的Task则无论什么时候都会被执行(即在configuration时便会执行其内部的语句）
task noActionTask{
    println "I am no Action Task!"
}

task TaskA{
    ext.property = "TaskA Property"
    doFirst{
        println 'TaskA doFirst'
    }

    doLast{
        println 'TaskA doLast'
    }
}
//dependsOn 建立task之间的依赖关系
//使用$符号作为Task的属性
task TaskB(dependsOn:"TaskA"){
    doFirst{
        println "TaskB doFirst $TaskB.name"
//        定一TaskA的属性 从TaskB中获取
        println "Get TaskA Property from TaskB: $TaskA.property"
    }

    println("I am a TaskB Method!")
}

//不能通过该方式构造Task的依赖,该方式构造的Task依赖会造成一个循环依赖
TaskA.dependsOn deps

//动态生成task
4.times {counter->
    task "task$counter"{
        doFirst{
            println "I am task$counter doFirst"
        }
}}

//在task外部定义task之间的依赖关系(被依赖的task按照task名称的字典顺序被先后执行)
task0.dependsOn task2,task1,task3

repositories{
    maven{
        url "www.google.com"
    }
}

//调用apply方法，传入一个map
//apply plugin:"com.android.application"

allprojects{
    repositories{
        google()
    }
}

dependencies{
//    compile ""
}

//创建目录树打印出当前目录树的所有文件
//def filetree = fileTree("./")
//filetree.each {
//    println it.getAbsolutePath()
//}

//copy 类型的Task可以很方便的进行任务的Copy操作
task SeflCopyTask(type:Copy){
    from './'
    into './new/'
}
//Wrapper的Task用于生成 wrapper目录 和 gradlew以及gradlew.bat文件
task createWrapper(type:Wrapper){
    gradleVersion='4.4'
}

task TryZip(type: Zip){
    from "gradlew"
    doFirst{
       println "task TryZip"
        def val = rootProject.extensions.ext.key + rootProject.ext.key2
        println "Value is $val"

        println "Type of extensions${rootProject.extensions.getClass()}"

        println "Type of extensions.ext: ${rootProject.extensions.ext.getClass()}"

        println "Add Extensions: ${rootProject.extensions.getByName("ke")}"

    }
}

//打印startParameter参数
//def startParameter = gradle.startParameter.toString()
//println "StartParameter: ${startParameter}"

gradle.taskGraph.whenReady {
    def taskSize = gradle.taskGraph.getAllTasks().size()
    println "TaskSize : ${taskSize}"

//    通过名称获取TaskB
    def taskBSet = project.getTasksByName(("TaskB"),false)
    println "GetTaskByName: ${taskBSet.size()}"
//    通过TaskB 获取TaskB的依赖Task !!!!!todo:目前无法获取到该TaskB getDependencies是从4.6开始有的
//    def dependsTaskSize = gradle.taskGraph.getDependencies(taskBSet[0] as Task).size()
//    println "TaskDepends Size: ${dependsTaskSize}"

//    打印当前的Project的类型:DefaultProject_Decorated todo://什么时候创建的?
    println "Project Type: ${project.getClass().getCanonicalName()}"
//    打印gradle
    println "Gradle type: ${gradle.getClass().getCanonicalName()}"

//    获取getConfigurationActions
//    println "ConfigurationActions: ${project.getConfigurations()}"

//    获取当前Task的类 类型
    println "Task Type :${taskBSet[0].getClass().getCanonicalName()}"

    def list = ['a','b','c','d','e','f','g']
    def closure = {
        it.toUpperCase()
    }
    println "Closure this : ${closure.getThisObject()}"
//    println "Closure owner: ${closure.getOwner()}"
//    println "Closure delegate: ${closure.getDelegate()}"
    def listUpper = list.collect closure
    println "UpperList: ${listUpper}"
//获取task 然后使用task
    def taskB =project.tasks.getByName("TaskB")
    println "Task :${taskB.project}"

}


extensions.add("ke","ve")

ext{
    key="value"
}
ext.key2 = "value2"

//????直接使用task名字去添加依赖关系 这是什么语法?
TryZip.dependsOn task0

//为所有子项目注入相应的配置
subprojects{

}

dependencies{

    compile "org.hibernate:hibernate:3.1"
    println("DDDD")
}


//输出:org.gradle.api.plugins.JavaPlugin@240e96eb
//def java = getPlugins().getPlugin("java")
//println(java)

//直接使用task的名称引用定义的Task 并且输出其名称
println("taskB name:${task("taskB")}")
//通过Project的property方法获得对象
println("taskB name(via Project#property): ${property("taskB")}")
//如果定义了ext.taskB则通过property获取到的则是ext定义的扩展字段,property的获取是有顺序的,上层存在该值则不会取下层的值
project.ext.taskB = "I am TaskB ext!"
println("defin ext.taskB !taskB name(via Project#property): ${property("taskB")}")

//定义一个闭包作为ext的参数,然后获取该闭包并且执行
project.ext.closure = {println "execute ext closure"}
//获取定义的闭包并且执行
//property("closure")()

//直接通过动态方法进行执行
closure()

//build.gradle 内部可以调用的动态方法 (动态方法的寻找策略,task也可以作为一个方法被调用,需要传出Closure)
task taskFunc(){
    println "println taskFunc"
}

taskFunc({println "task execute closure"})

//println("Convention ${project.getConvention().getPlugin(JavaPluginConvention.class)}")


//验证通过 apply plugin:'java' 与 apply plugin: 'org.gradle.plugin'插件是否是同一个插件
//通过两种不同的id导入的插件其实是同一个插件
//println("Java Plugin: ${project.getPlugins().getPlugin('java')}")

//遍历当前的所持有的Plugin
println("Plugins: ${project.getPlugins().each { println "Each Plugin: ${it}" }}")
//遍历所有当前持有的Convention
project.getConvention().getPlugins().each {println "Each Convention: ${it.getValue()}"}


//4.6的gradle才可以使用 gradle.getTaskGraph().getDependencies 方法
//rootProject.gradle.taskGraph.whenReady { gradle.getTaskGraph().getDependencies(project.getTasksByName("taskB",false)[0])}
println "Dependence Graph: "

//定义一个自己的Convention加入Project

//便可以在Project内部调用Convention的方法了
class SelfDefinitionConvention{
    public void selfDefinition(){
        println("call self definition!@@@@")
    }
}

project.getConvention().getPlugins().put("sefl.definition",new SelfDefinitionConvention())

selfDefinition()

//ext 是在DefaultConvention中定义的
//build.gradle 中用户自己添加的ke也可以直接使用Project的property方法获取到 extensions.add("ke","ve")
println "just get property ${project.ke}"

//hook 查看System Property 属性
def property = System.getProperty("org.gradle.appname","test")
println "Property: ${property}"
