# 函数一等公民

## 函数式编程

函数式编程（functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将计算机运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。

### 函数式编程的本质

函数式编程中的函数这个术语不是指计算机中的函数（实际上是Subroutine），而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。

在函数式语言中，函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。

纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的（immutable），也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写“x = x + 1”，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。

函数式语言的如条件语句，循环语句也不是命令式编程语言中的控制语句，而是函数的语法糖，比如在Scala语言中，if else不是语句而是三元运算符，是有返回值的。

严格意义上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式控制结构进行编程。

从理论上说，函数式语言也不是通过冯诺伊曼体系结构的机器上运行的，而是通过λ演算来运行的，就是通过变量替换的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是图灵完全（Turing completeness）的，但是大多数情况，函数式程序还是被编译成（冯诺依曼机的）机器语言的指令执行的

### 函数式编程的特性

函数是"一等公民"：函数优先，和其他数据类型一样。
只用"表达式"，不用"语句"：通过表达式（expression）计算过程得到一个返回值，而不是通过一个语句（statement）修改某一个状态。
无副作用：不污染变量，同一个输入永远得到同一个数据。
不可变性：前面一提到，不修改变量，返回一个新的值。
由于变量值是不可变的，对于值的操作并不是修改原来的值，而是修改新产生的值，原来的值保持不便。 通常来说，算法都有递推（iterative）和递归（recursive）两种定义。

由于变量不可变，纯函数编程语言无法实现循环，这是因为For循环使用可变的状态作为计数器，而While循环或DoWhile循环需要可变的状态作为跳出循环的条件。因此在函数式语言里就只能使用递归来解决迭代问题，这使得函数式编程严重依赖递归

### 函数式编程的其他特性

- 高阶函数（Higher-order function）：就是参数为函数或返回值为函数的函数。有了高阶函数，就可以将复用的粒度降低到函数级别，相对于面向对象语言，复用的粒度更低。
  
- 偏应用函数（Partially Applied Functions）：一个函数接收一个有多个参数的函数，返回一个需要较少参数的函数。偏函数将一到多个参数在内部固定，然后返回新函数，返回的函数接收剩余的参数完成函数的应用。
  
- 柯里化（Currying）：输入一个有多个参数的函数， 返回一个只接收单个参数的函数。

- 闭包（Closure）：闭包就是有权访问另一个函数作用域中变量的函数.闭包的三个特性：1.闭包是定义在函数中的函数 。2.闭包能访问包含函数的变量。3.即使包含函数执行完了, 被闭包引用的变量也得不到释放。具体参看 [闲话闭包](https://www.zhoulujun.cn/html/webfront/ECMAScript/js6/2015_0814_240.html)

### 函数式编程的好处

由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是引用透明（Referential transparency）的和没有副作用（No Side Effect）。

函数既不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。

由于（多个线程之间）不共享状态，不会造成资源争用(Race condition)，也就不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地并发起来，尤其是在对称多处理器（SMP）架构下能够更好地利用多个处理器（核）提供的并行处理能力。

我觉得函数编程的好处就不用管js里面该死的this指向

函数式编程语言还提供惰性求值-Lazy evaluation，也称作call-by-need，是在将表达式赋值给变量（或称作绑定）时并不计算表达式的值，而在变量第一次被使用时才进行计算。这样就可以通过避免不必要的求值提升性能。

函数式编程天生亲和单元测(特别是黑盒测试)，因为FP关注就是输入与输出。反观Java或者C++，仅仅检查函数的返回值是不够的：代码可能修改外部状态值，因此我们还需要验证这些外部的状态值的正确性。在FP语言中呢，就完全不需要。

调试查错方面，因为FP程序中的错误不依赖于之前运行过的不相关的代码。而在一个指令式程序中，一个bug可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个bug完全不相关的代码通过某个特别的执行流程才能修改。在FP中这种情况完全不存在：如果一个函数的返回值出错了，它一直都会出错，无论你之前运行了什么代码。而整个程序就是函数接龙。

## References

- [闲话闭包](https://www.zhoulujun.cn/html/webfront/ECMAScript/js6/2015_0814_240.html)
  
- [函数式编程漫谈](https://cloud.tencent.com/developer/article/1190773)