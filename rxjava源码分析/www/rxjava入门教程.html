<!DOCTYPE html>
<html>
<head>
<title>rxjava入门教程.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E5%93%8D%E5%BA%94%E5%BC%8Frxjava%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8">响应式（rxjava)编程入门</h1>
<p>响应式编程作为一种编程范式在开源社区具有一种怎样的实践?响应式编程给我们带来了什么?更简洁的代码逻辑?更好的性能?更少的代码实现各种复杂的异步操作?本次我们基于 ReactiveX 系列开源项目中 java 语言实现 rxjava 来入门响应式编程.该系列的开源项目还有其他语言的实现如:RxJS,RxSwift,RxCpp,RxLua 等等,它们秉承着相同的思想在不同的语言平台上加以实践.</p>
<h2 id="%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B">响应式编程简介</h2>
<hr>
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B">什么是响应式编程</h3>
<ul>
<li>
<p>响应式编程</p>
<p>执行者作为观察者,等待指定事件,当指定事件触发才去执行动作.响应式编程调用方法不是直接去执行操作,而只是去注册事件监听器.因此响应式编程具有等待稍后执行的语义,执行行为只是对事件的一种响应,故此称为响应式编程.因此响应式编程其实是一种异步编程,当然也可以做到同步模式,但是这就失去了其真正的意义.也就是说响应式编程实质上基于事件驱动的异步编程模式.</p>
<p>根本上响应式编程也是非阻塞式编成,可以提升程序的整体性能.</p>
</li>
<li>
<p>命令式编程</p>
<p>调用方法即直接执行操作.(类似要x人立即去做xxx事情,故此叫命令式)</p>
</li>
<li>
<p>reactivex 项目的简述</p>
<p>Reactive Extensions for Async Programming (异步编程的响应式扩展)</p>
</li>
<li>
<p>rxjava 项目的简述</p>
<p>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.(一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库)</p>
</li>
</ul>
<p>那么现有的异步编程模式出现了什么问题？不好用？不好读？容易出错?对初学者不友好?</p>
<h3 id="rxjava-%E5%A5%BD%E5%9C%A8%E5%93%AA%E5%84%BF">RxJava 好在哪儿</h3>
<p>换句话说，『同样是做异步，为什么人们用它，而不用现成的 ScheduledExecutorService,ExecutorService,ForkJoinPool,Callable,FutureTask,CountDownLatch,CyclicBarrier,Semaphore,LinkedBlockingQueue,SynchronousQueue,PriorityBlockingQueue 等』</p>
<ul>
<li>
<p>简洁</p>
<p>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。但是 rxjava 随着程序逻辑变得越来越复杂，它依然能够保持简洁。该处需要强调的是逻辑复杂度变得简洁而不是代码量减少.(逻辑变得简洁才能提升代码的读写速度),使用rxjava 编写的异步程序可以一会儿排成人字一会儿排成一字.</p>
</li>
</ul>
<h3 id="%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80">响应式编程的基础</h3>
<ul>
<li>
<p>观察者模式,</p>
<p>Callback. 对于观察者模式则存在 Observable (被观察者) 和 Observer(观察者) 或者可以称之为 Subscriber (订阅者).对于回调我们需要有注册中心/事件中心/事件分发器也就是被观察者, CallBack 则是接受被观察者的调用.(一旦谈到回调,就无法回避 Callback hell 这个话题)</p>
</li>
<li>
<p>代理模式/装饰者模式/责任链模式</p>
<p>Observable 构建成的转换链实际上像是一种责任链.很多操作符的实现对 Observable 和 Observer 的包装/增强/限制 则更像是装饰者模式和代理模式.</p>
</li>
</ul>
<h3 id="%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</h3>
<p>函数式编程基础概念<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/</a></p>
<p>rxjava 很多概念和API 的设计上参考了函数式编程的基础概念,如 Maybe,map等操作符号传入的函数接口则对应于高阶函数的概念,Observable的转换链的建立则和柯里化的概念很像.</p>
<p>简单提一下柯里化(curry):</p>
<p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) </span>{
    <span class="hljs-keyword">return</span> x + y;
  };
};

<span class="hljs-keyword">var</span> increment = add(<span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> addTen = add(<span class="hljs-number">10</span>);

increment(<span class="hljs-number">2</span>);
<span class="hljs-comment">// 3</span>

addTen(<span class="hljs-number">2</span>);
<span class="hljs-comment">// 12</span>

<span class="hljs-comment">// lodash 组建提供的柯里化操作</span>

<span class="hljs-keyword">var</span> curry = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>).curry;

<span class="hljs-keyword">var</span> match = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what, str</span>) </span>{
  <span class="hljs-keyword">return</span> str.match(what);
});

<span class="hljs-keyword">var</span> replace = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what, replacement, str</span>) </span>{
  <span class="hljs-keyword">return</span> str.replace(what, replacement);
});

<span class="hljs-keyword">var</span> filter = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, ary</span>) </span>{
  <span class="hljs-keyword">return</span> ary.filter(f);
});

<span class="hljs-keyword">var</span> map = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, ary</span>) </span>{
  <span class="hljs-keyword">return</span> ary.map(f);
});

match(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">"hello world"</span>);
<span class="hljs-comment">// [ ' ' ]</span>

match(<span class="hljs-regexp">/\s+/g</span>)(<span class="hljs-string">"hello world"</span>);
<span class="hljs-comment">// [ ' ' ]</span>

<span class="hljs-keyword">var</span> hasSpaces = match(<span class="hljs-regexp">/\s+/g</span>);
<span class="hljs-comment">// function(x) { return x.match(/\s+/g) }</span>

hasSpaces(<span class="hljs-string">"hello world"</span>);
<span class="hljs-comment">// [ ' ' ]</span>

hasSpaces(<span class="hljs-string">"spaceless"</span>);
<span class="hljs-comment">// null</span>

filter(hasSpaces, [<span class="hljs-string">"tori_spelling"</span>, <span class="hljs-string">"tori amos"</span>]);
<span class="hljs-comment">// ["tori amos"]</span>

<span class="hljs-keyword">var</span> findSpaces = filter(hasSpaces);
<span class="hljs-comment">// function(xs) { return xs.filter(function(x) { return x.match(/\s+/g) }) }</span>

findSpaces([<span class="hljs-string">"tori_spelling"</span>, <span class="hljs-string">"tori amos"</span>]);
<span class="hljs-comment">// ["tori amos"]</span>

<span class="hljs-keyword">var</span> noVowels = replace(<span class="hljs-regexp">/[aeiou]/ig</span>);
<span class="hljs-comment">// function(replacement, x) { return x.replace(/[aeiou]/ig, replacement) }</span>

<span class="hljs-keyword">var</span> censored = noVowels(<span class="hljs-string">"*"</span>);
<span class="hljs-comment">// function(x) { return x.replace(/[aeiou]/ig, "*") }</span>

censored(<span class="hljs-string">"Chocolate Rain"</span>);
<span class="hljs-comment">// 'Ch*c*l*t* R**n'</span>

</div></code></pre>
<p>在 js 中函数可能算是一等公民,kotlin 中也可以便捷写出柯里化模式的方法.java 对象是一等公民的语言实现柯里化则比较费劲.但是java其实也在积极的引入函数式编程. java 中的 lambda,函数式接口,方法引用,stream流,引入invokedynamic 指令.</p>
<p>下面的 rxjava 代码均以 rxjava2 版本作为基础.虽然 rxjava2 将于 2021.02 停止维护.目前最新版本 rxjava3.[rxjava1 rxjava2 向 rxjava3 的迁移手册]<a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-3.0">https://github.com/ReactiveX/RxJava/wiki/What's-different-in-3.0</a> rxjava1 rxjava2 rxjava3 在同一个项目中是可以并存的.rxjava1 的实现由于历史原因实现的并不好,但是 rxjava1 制定出的操作附语义,基础高性能非阻塞算法并没有太多改变.rxjava2 的实现由于响应式编程规范接口的诞生,同时根据rxjava1在实践中产生的问题,修改了很多操作符实现的架构模式,并且修复了 rxjava1 由于架构问题而没有办法修复的问题.本质上 rxjava2 对于 rxjava1 则是一次比较大的改动,改动主要在实现的架构模式上和对接新的异步编程规范接口上. rxjava3 相对于 rxjava2 所做的工作则更多的是功能的增强,优化.</p>
<p>rxjava1 中没有实现响应式编程的规范接口,因为该规范出现在 2014年1月(开始制定),而rxjava1则是从2012年3月开始开发的.</p>
<h2 id="rxjava-%E5%AE%9E%E6%88%98%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">rxjava 实战(异步编程)</h2>
<hr>
<h3 id="%E8%A7%A3%E5%86%B3-callback-hell">解决 Callback hell</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> io.reactivex.*;
<span class="hljs-keyword">import</span> io.reactivex.functions.Consumer;
<span class="hljs-keyword">import</span> io.reactivex.functions.Function;
<span class="hljs-keyword">import</span> io.reactivex.schedulers.Schedulers;

<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallBackHell</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService CACHED_EXECUTOR_SERVICE = Executors.newCachedThreadPool();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonInfo</span> </span>{

        <span class="hljs-keyword">public</span> String token;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonInfo</span><span class="hljs-params">(String token)</span> </span>{
            <span class="hljs-keyword">this</span>.token = token;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TradeData</span> </span>{
        <span class="hljs-keyword">public</span> String id;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TradeData</span><span class="hljs-params">(String id)</span> </span>{
            <span class="hljs-keyword">this</span>.id = id;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TradeDetail</span> </span>{
        <span class="hljs-keyword">public</span> String content;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TradeDetail</span><span class="hljs-params">(String content)</span> </span>{
            <span class="hljs-keyword">this</span>.content = content;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GetPersonCallBack</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(PersonInfo personInfo)</span></span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span></span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GetTradeDetailCallBack</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeDetail tradeDetail)</span></span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span></span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GetTradeDataCallBack</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeData tradedata)</span></span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span></span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getPersonInfo</span><span class="hljs-params">(String acc, String pwd, GetPersonCallBack getPersonCallBack)</span> </span>{
        CACHED_EXECUTOR_SERVICE.submit(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                getPersonCallBack.onSucces(<span class="hljs-keyword">new</span> PersonInfo(<span class="hljs-string">"token"</span>));
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTradeData</span><span class="hljs-params">(String token, GetTradeDataCallBack getTradeDataCallBack)</span> </span>{
        CACHED_EXECUTOR_SERVICE.submit(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                getTradeDataCallBack.onSucces(<span class="hljs-keyword">new</span> TradeData(<span class="hljs-string">"id"</span>));
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTradeDetail</span><span class="hljs-params">(String id, GetTradeDetailCallBack getTradeDetailCallBack)</span> </span>{
        CACHED_EXECUTOR_SERVICE.submit(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                getTradeDetailCallBack.onSucces(<span class="hljs-keyword">new</span> TradeDetail(<span class="hljs-string">"content"</span>));
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
<span class="hljs-comment">//        旧的 callbackHell</span>
        getPersonInfo(<span class="hljs-string">"acc"</span>, <span class="hljs-string">"pwd"</span>, <span class="hljs-keyword">new</span> GetPersonCallBack() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(PersonInfo personInfo)</span> </span>{
                getTradeData(personInfo.token, <span class="hljs-keyword">new</span> GetTradeDataCallBack() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeData tradedata)</span> </span>{
                        getTradeDetail(tradedata.id, <span class="hljs-keyword">new</span> GetTradeDetailCallBack() {
                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeDetail tradeDetail)</span> </span>{
                                System.out.println(<span class="hljs-string">"Call Back hell Detail:"</span> + tradeDetail.content);
                            }

                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{

                            }
                        });
                    }

                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{

                    }
                });
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{

            }
        });


<span class="hljs-comment">//        rxjava wrapped</span>
        getPersonInfoObWrapp(<span class="hljs-string">"acc"</span>, <span class="hljs-string">"pwd"</span>)
                .flatMap(<span class="hljs-keyword">new</span> Function&lt;PersonInfo, ObservableSource&lt;TradeData&gt;&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> ObservableSource&lt;TradeData&gt; <span class="hljs-title">apply</span><span class="hljs-params">(PersonInfo personInfo)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        <span class="hljs-keyword">return</span> getTradeDataObWrapp(personInfo.token);
                    }
                })
                .flatMap(<span class="hljs-keyword">new</span> Function&lt;TradeData, ObservableSource&lt;TradeDetail&gt;&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> ObservableSource&lt;TradeDetail&gt; <span class="hljs-title">apply</span><span class="hljs-params">(TradeData tradeData)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        <span class="hljs-keyword">return</span> getTradeDetailObWrapp(tradeData.id);
                    }
                })
                .observeOn(Schedulers.trampoline())
                .subscribe(<span class="hljs-keyword">new</span> Consumer&lt;TradeDetail&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(TradeDetail tradeDetail)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        System.out.println(<span class="hljs-string">"RxJava Wrap Detail:"</span> + tradeDetail.content);
                    }
                });
<span class="hljs-comment">// no wrap rxjava</span>

        getPersonInfoOb(<span class="hljs-string">"acc"</span>, <span class="hljs-string">"pwd"</span>)
                .flatMap(<span class="hljs-keyword">new</span> Function&lt;PersonInfo, ObservableSource&lt;TradeData&gt;&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> ObservableSource&lt;TradeData&gt; <span class="hljs-title">apply</span><span class="hljs-params">(PersonInfo personInfo)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        <span class="hljs-keyword">return</span> getTradeDataOb(personInfo.token);
                    }
                })
                .flatMap(<span class="hljs-keyword">new</span> Function&lt;TradeData, ObservableSource&lt;TradeDetail&gt;&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> ObservableSource&lt;TradeDetail&gt; <span class="hljs-title">apply</span><span class="hljs-params">(TradeData tradeData)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        <span class="hljs-keyword">return</span> getTradeDetailOb(tradeData.id);
                    }
                })
                .observeOn(Schedulers.trampoline())
                .subscribe(<span class="hljs-keyword">new</span> Consumer&lt;TradeDetail&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(TradeDetail tradeDetail)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        System.out.println(<span class="hljs-string">"RxJava NoWrap Detail:"</span> + tradeDetail.content);
                    }
                });

    }
    <span class="hljs-comment">// 包装老的接口进入 rxjava 的模式</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;PersonInfo&gt; <span class="hljs-title">getPersonInfoObWrapp</span><span class="hljs-params">(String acc, String pwd)</span> </span>{
        <span class="hljs-keyword">return</span> Observable.&lt;PersonInfo&gt;create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;PersonInfo&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;PersonInfo&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                getPersonInfo(acc, pwd, <span class="hljs-keyword">new</span> GetPersonCallBack() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(PersonInfo personInfo)</span> </span>{
                        emitter.onNext(personInfo);
                        emitter.onComplete();
                    }

                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{
                        emitter.onError(<span class="hljs-keyword">new</span> Throwable());
                    }
                });
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;TradeData&gt; <span class="hljs-title">getTradeDataObWrapp</span><span class="hljs-params">(String token)</span> </span>{
        <span class="hljs-keyword">return</span> Observable.&lt;TradeData&gt;create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;TradeData&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;TradeData&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                getTradeData(token, <span class="hljs-keyword">new</span> GetTradeDataCallBack() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeData tradeData)</span> </span>{
                        emitter.onNext(tradeData);
                        emitter.onComplete();
                    }

                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{
                        emitter.onError(<span class="hljs-keyword">new</span> Throwable());
                    }
                });
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;TradeDetail&gt; <span class="hljs-title">getTradeDetailObWrapp</span><span class="hljs-params">(String id)</span> </span>{
        <span class="hljs-keyword">return</span> Observable.&lt;TradeDetail&gt;create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;TradeDetail&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;TradeDetail&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                getTradeDetail(id, <span class="hljs-keyword">new</span> GetTradeDetailCallBack() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeDetail tradeDetail)</span> </span>{
                        emitter.onNext(tradeDetail);
                        emitter.onComplete();
                    }

                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{
                        emitter.onError(<span class="hljs-keyword">new</span> Throwable());
                    }
                });
            }
        });
    }

<span class="hljs-comment">//    新写的接口直接 rxjava 模式</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;PersonInfo&gt; <span class="hljs-title">getPersonInfoOb</span><span class="hljs-params">(String acc, String pwd)</span> </span>{
        <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-string">"start"</span>)
                         .map(<span class="hljs-keyword">new</span> Function&lt;String, PersonInfo&gt;() {
                             <span class="hljs-meta">@Override</span>
                             <span class="hljs-function"><span class="hljs-keyword">public</span> PersonInfo <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                 Thread.sleep(<span class="hljs-number">1000</span>);
                                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PersonInfo(<span class="hljs-string">"token"</span>);
                             }
                         })
                         .subscribeOn(Schedulers.io());
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;TradeData&gt; <span class="hljs-title">getTradeDataOb</span><span class="hljs-params">(String token)</span> </span>{
        <span class="hljs-keyword">return</span> Observable.just(token)
                         .map(<span class="hljs-keyword">new</span> Function&lt;String, TradeData&gt;() {
                             <span class="hljs-meta">@Override</span>
                             <span class="hljs-function"><span class="hljs-keyword">public</span> TradeData <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                 Thread.sleep(<span class="hljs-number">1000</span>);
                                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TradeData(<span class="hljs-string">"id"</span>);
                             }
                         })
                         .subscribeOn(Schedulers.io());
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;TradeDetail&gt; <span class="hljs-title">getTradeDetailOb</span><span class="hljs-params">(String id)</span> </span>{

        <span class="hljs-keyword">return</span> Observable.just(id)
                         .map(<span class="hljs-keyword">new</span> Function&lt;String, TradeDetail&gt;() {
                             <span class="hljs-meta">@Override</span>
                             <span class="hljs-function"><span class="hljs-keyword">public</span> TradeDetail <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                 Thread.sleep(<span class="hljs-number">1000</span>);
                                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TradeDetail(<span class="hljs-string">"content"</span>);
                             }
                         })
                         .subscribeOn(Schedulers.io());
    }

}
</div></code></pre>
<p>解决回调地狱在很多语言中都提供了一些解决方案:</p>
<ul>
<li>
<p>JS 中的 Promise,async,await</p>
</li>
<li>
<p>Kotlin 中以协程为基础的 suspend fun (挂起方法)</p>
</li>
</ul>
<h3 id="%E8%A7%A3%E5%86%B3%E9%A2%91%E7%B9%81%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E9%9C%80%E6%B1%82">解决频繁执行线程切换的需求</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> io.reactivex.Observable;
<span class="hljs-keyword">import</span> io.reactivex.Observer;
<span class="hljs-keyword">import</span> io.reactivex.disposables.Disposable;
<span class="hljs-keyword">import</span> io.reactivex.functions.Function;
<span class="hljs-keyword">import</span> io.reactivex.schedulers.Schedulers;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadChange</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        Observable.just(<span class="hljs-string">"start"</span>)
                  .observeOn(Schedulers.io())
                  .map(<span class="hljs-keyword">new</span> Function&lt;String, String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                          System.out.println(<span class="hljs-string">"Map1 Thread:"</span> + Thread.currentThread());
                          <span class="hljs-keyword">return</span> s + <span class="hljs-string">" map1 io "</span>;
                      }
                  })
                  .observeOn(Schedulers.computation())
                  .map(<span class="hljs-keyword">new</span> Function&lt;String, String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                          System.out.println(<span class="hljs-string">"Map2 Thread:"</span> + Thread.currentThread());
                          <span class="hljs-keyword">return</span> s + <span class="hljs-string">"map2 computation"</span>;
                      }
                  })
                  .observeOn(Schedulers.newThread())
                  .map(<span class="hljs-keyword">new</span> Function&lt;String, String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                          System.out.println(<span class="hljs-string">"Map3 Thread:"</span> + Thread.currentThread());
                          <span class="hljs-keyword">return</span> s + <span class="hljs-string">" map3 newThread"</span>;
                      }
                  })
                  .observeOn(Schedulers.single())
                  .map(<span class="hljs-keyword">new</span> Function&lt;String, String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                          System.out.println(<span class="hljs-string">"Map4 Thread:"</span> + Thread.currentThread());
                          <span class="hljs-keyword">return</span> s + <span class="hljs-string">" map4 single"</span>;
                      }
                  })
                  .subscribe(<span class="hljs-keyword">new</span> Observer&lt;String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{

                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String s)</span> </span>{
                          System.out.println(<span class="hljs-string">"onNext Thread:"</span> + Thread.currentThread());
                          System.out.println(<span class="hljs-string">"onNext:"</span> + s);
                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{

                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{

                      }
                  });
        Thread.sleep(<span class="hljs-number">1000</span>);
    }
}
<span class="hljs-comment">//    OUT_PUT:</span>
<span class="hljs-comment">//    Map1 Thread:Thread[RxCachedThreadScheduler-1,5,main]</span>
<span class="hljs-comment">//    Map2 Thread:Thread[RxComputationThreadPool-1,5,main]</span>
<span class="hljs-comment">//    Map3 Thread:Thread[RxNewThreadScheduler-1,5,main]</span>
<span class="hljs-comment">//    Map4 Thread:Thread[RxSingleScheduler-1,5,main]</span>
<span class="hljs-comment">//    onNext Thread:Thread[RxSingleScheduler-1,5,main]</span>
<span class="hljs-comment">//    onNext:start map1 io map2 computation map3 newThread map4 single</span>
</div></code></pre>
<h3 id="%E5%90%8C%E6%AD%A5%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83">同步两个异步请求/并发计算同步回调</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> com.google.common.collect.Lists;
<span class="hljs-keyword">import</span> io.reactivex.Observable;
<span class="hljs-keyword">import</span> io.reactivex.functions.BiFunction;
<span class="hljs-keyword">import</span> io.reactivex.functions.Consumer;
<span class="hljs-keyword">import</span> io.reactivex.functions.Function;
<span class="hljs-keyword">import</span> io.reactivex.schedulers.Schedulers;

<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;

<span class="hljs-comment">//要实现 先请求个人信息,然后并发请求交易概括和交易详情,然后将交易详情组合进入交易概括内部</span>
<span class="hljs-comment">//用 java 实现则需要使用 CountDownLatch</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZipObservable</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService CACHED_EXECUTOR_SERVICE = Executors.newCachedThreadPool();


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{

<span class="hljs-comment">//        java 实现</span>
        <span class="hljs-keyword">final</span> List&lt;String&gt;[] overView = <span class="hljs-keyword">new</span> List[]{<span class="hljs-keyword">null</span>};
        <span class="hljs-keyword">final</span> List&lt;String&gt;[] tradeDetail = <span class="hljs-keyword">new</span> List[]{<span class="hljs-keyword">null</span>};

        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);
        getPersonInfo(<span class="hljs-string">"acc"</span>, <span class="hljs-string">"pwd"</span>, <span class="hljs-keyword">new</span> GetPersonCallBack() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(PersonInfo personInfo)</span> </span>{
                getTradeDetails(personInfo.token, <span class="hljs-keyword">new</span> GetTradeDetailsCallBack() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeDetails tradedetails)</span> </span>{
                        tradeDetail[<span class="hljs-number">0</span>] = tradedetails.details;
                        countDownLatch.countDown();
                    }

                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{

                    }
                });

                getTradeOverView(personInfo.token, <span class="hljs-keyword">new</span> GetTradeOverViewCallBack() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeOverView tradeoverview)</span> </span>{
                        overView[<span class="hljs-number">0</span>] = tradeoverview.overviews;
                        countDownLatch.countDown();
                    }

                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{

                    }
                });
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span> </span>{

            }
        });

        countDownLatch.await();
<span class="hljs-comment">//        合并 detail 进入 Overview</span>
        System.out.println(<span class="hljs-string">"OverView:"</span> + Arrays.deepToString(overView[<span class="hljs-number">0</span>].toArray()) + <span class="hljs-string">"Details:"</span> + Arrays.deepToString(tradeDetail[<span class="hljs-number">0</span>].toArray()));

<span class="hljs-comment">//        rxjava 实现</span>
        getPersonInfoOb(<span class="hljs-string">"acc"</span>, <span class="hljs-string">"pwd"</span>)
                .flatMap(
                        <span class="hljs-keyword">new</span> Function&lt;PersonInfo, Observable&lt;String&gt;&gt;() {
                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;String&gt; <span class="hljs-title">apply</span><span class="hljs-params">(PersonInfo personInfo)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                <span class="hljs-keyword">return</span> Observable.zip(getTradeOverViewOb(personInfo.token), getTradeDetailOb(personInfo.token),
                                        <span class="hljs-keyword">new</span> BiFunction&lt;TradeOverView, TradeDetails, String&gt;() {
                                            <span class="hljs-meta">@Override</span>
                                            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(TradeOverView tradeOverView, TradeDetails tradeDetails)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                                System.out.println(<span class="hljs-string">"Rx OverView:"</span> + Arrays.deepToString(tradeOverView.overviews.toArray())
                                                        + <span class="hljs-string">"Details:"</span> + Arrays.deepToString(tradeDetails.details.toArray()));

                                                <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
                                            }
                                        });
                            }
                        })
                .subscribe(<span class="hljs-keyword">new</span> Consumer&lt;String&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        System.out.println(<span class="hljs-string">"RxResult:"</span> + s);
                    }
                });

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonInfo</span> </span>{

        <span class="hljs-keyword">public</span> String token;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonInfo</span><span class="hljs-params">(String token)</span> </span>{
            <span class="hljs-keyword">this</span>.token = token;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TradeOverView</span> </span>{
        <span class="hljs-keyword">public</span> List&lt;String&gt; overviews;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TradeOverView</span><span class="hljs-params">(List&lt;String&gt; overviews)</span> </span>{
            <span class="hljs-keyword">this</span>.overviews = overviews;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TradeDetails</span> </span>{
        <span class="hljs-keyword">public</span> List&lt;String&gt; details;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TradeDetails</span><span class="hljs-params">(List&lt;String&gt; details)</span> </span>{
            <span class="hljs-keyword">this</span>.details = details;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GetTradeOverViewCallBack</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeOverView tradeoverview)</span></span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span></span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GetTradeDetailsCallBack</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(TradeDetails tradedetails)</span></span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span></span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GetPersonCallBack</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSucces</span><span class="hljs-params">(PersonInfo personInfo)</span></span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">()</span></span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getPersonInfo</span><span class="hljs-params">(String acc, String pwd, GetPersonCallBack getPersonCallBack)</span> </span>{
        CACHED_EXECUTOR_SERVICE.submit(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                getPersonCallBack.onSucces(<span class="hljs-keyword">new</span> PersonInfo(<span class="hljs-string">"token"</span>));
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTradeOverView</span><span class="hljs-params">(String token, GetTradeOverViewCallBack getTradeOverViewCallBack)</span> </span>{
        CACHED_EXECUTOR_SERVICE.submit(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                getTradeOverViewCallBack.onSucces(<span class="hljs-keyword">new</span> TradeOverView(Lists.newArrayList(<span class="hljs-string">"over 11"</span>, <span class="hljs-string">"over 22"</span>, <span class="hljs-string">"over 33"</span>)));
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTradeDetails</span><span class="hljs-params">(String token, GetTradeDetailsCallBack getTradeDetailsCallBack)</span> </span>{
        CACHED_EXECUTOR_SERVICE.submit(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                getTradeDetailsCallBack.onSucces(<span class="hljs-keyword">new</span> TradeDetails(Lists.newArrayList(<span class="hljs-string">"detail 11"</span>, <span class="hljs-string">"detail 22"</span>, <span class="hljs-string">"detail 33"</span>)));
            }
        });
    }


    <span class="hljs-comment">//    新写的接口直接 rxjava 模式</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;PersonInfo&gt; <span class="hljs-title">getPersonInfoOb</span><span class="hljs-params">(String acc, String pwd)</span> </span>{
        <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-string">"start"</span>)
                         .map(<span class="hljs-keyword">new</span> Function&lt;String, PersonInfo&gt;() {
                             <span class="hljs-meta">@Override</span>
                             <span class="hljs-function"><span class="hljs-keyword">public</span> PersonInfo <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                 Thread.sleep(<span class="hljs-number">1000</span>);
                                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PersonInfo(<span class="hljs-string">"token"</span>);
                             }
                         })
                         .subscribeOn(Schedulers.io());
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;TradeOverView&gt; <span class="hljs-title">getTradeOverViewOb</span><span class="hljs-params">(String token)</span> </span>{
        <span class="hljs-keyword">return</span> Observable.just(token)
                         .map(<span class="hljs-keyword">new</span> Function&lt;String, TradeOverView&gt;() {
                             <span class="hljs-meta">@Override</span>
                             <span class="hljs-function"><span class="hljs-keyword">public</span> TradeOverView <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                 Thread.sleep(<span class="hljs-number">1000</span>);
                                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TradeOverView(Lists.newArrayList(<span class="hljs-string">"over 11"</span>, <span class="hljs-string">"over 22"</span>, <span class="hljs-string">"over 33"</span>));
                             }
                         })
                         .subscribeOn(Schedulers.io());
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;TradeDetails&gt; <span class="hljs-title">getTradeDetailOb</span><span class="hljs-params">(String id)</span> </span>{

        <span class="hljs-keyword">return</span> Observable.just(id)
                         .map(<span class="hljs-keyword">new</span> Function&lt;String, TradeDetails&gt;() {
                             <span class="hljs-meta">@Override</span>
                             <span class="hljs-function"><span class="hljs-keyword">public</span> TradeDetails <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                                 Thread.sleep(<span class="hljs-number">1000</span>);
                                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TradeDetails(Lists.newArrayList(<span class="hljs-string">"detail 11"</span>, <span class="hljs-string">"detail 22"</span>, <span class="hljs-string">"detail 33"</span>));
                             }
                         })
                         .subscribeOn(Schedulers.io());
    }
}
</div></code></pre>
<ul>
<li>
<p>zip 与 CountDownLatch 实现的区别</p>
<p>zip 是基于非阻塞算法进行的, CountDownLatch 则是在 CountDownLatch#await 时会使用 LockSupport#park 操作阻塞线程,虽然不占用太多cpu资源,但是占用了进程的线程资源(系统对于每个进程创建的最大线程是有限制的)</p>
</li>
<li>
<p>如何给异步请求添加超时机制</p>
<p>对 Zip 操作的每个 Observable添加一个 timeout 操作符即可.</p>
</li>
</ul>
<h3 id="%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83%E5%A4%9A%E6%92%AD%E5%8D%95%E6%92%AD%E9%87%8D%E6%92%AD%E6%9C%80%E6%96%B0%E7%9A%84%E4%BA%8B%E4%BB%B6">实现通用的事件中心(多播/单播/重播/最新的事件)</h3>
<p>在 Android 中需要使用 LocalBroadcastManager (可以实现复杂的事件下发机制).在 java 中则需要基于 java.util.Observable 和 java.util.Observer 实现.或者引入别人实现的功能强大的事件总线库.</p>
<ul>
<li>基于 JDK 实现的事件中心</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> java.util.Observable;
<span class="hljs-keyword">import</span> java.util.Observer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaEventCenter</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{

<span class="hljs-comment">//        下发时要设置 setChanged 否则该事件会被忽略</span>

        Observable eventCenter = <span class="hljs-keyword">new</span> Observable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Object arg)</span> </span>{
                setChanged();
                <span class="hljs-keyword">super</span>.notifyObservers(arg);
            }
        };

        Observer manObserver = <span class="hljs-keyword">new</span> Observer() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>{
                System.out.println(<span class="hljs-string">"Man Observer Type:"</span> + arg.getClass()
                                                             .getSimpleName());
                <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> Man) {
                    System.out.println(<span class="hljs-string">"Man Receive:"</span> + ((Man) arg).name);
                }
            }
        };

        Observer woManObserver = <span class="hljs-keyword">new</span> Observer() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>{
                System.out.println(<span class="hljs-string">"Woman Observer Type:"</span> + arg.getClass()
                                                             .getSimpleName());
                <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> Woman) {
                    System.out.println(<span class="hljs-string">"Woman Receive:"</span> + ((Woman) arg).name);
                }
            }
        };
        eventCenter.notifyObservers(<span class="hljs-keyword">new</span> Human(<span class="hljs-string">"human 1"</span>));

        eventCenter.addObserver(manObserver);

        eventCenter.notifyObservers(<span class="hljs-keyword">new</span> Human(<span class="hljs-string">"Human 1"</span>));
        eventCenter.notifyObservers(<span class="hljs-keyword">new</span> Man(<span class="hljs-string">"Man 1"</span>));
        eventCenter.notifyObservers(<span class="hljs-keyword">new</span> Woman(<span class="hljs-string">"Woman 1"</span>));

        eventCenter.addObserver(woManObserver);

        eventCenter.notifyObservers(<span class="hljs-keyword">new</span> Human(<span class="hljs-string">"Human 2"</span>));
        eventCenter.notifyObservers(<span class="hljs-keyword">new</span> Man(<span class="hljs-string">"Man 2"</span>));
        eventCenter.notifyObservers(<span class="hljs-keyword">new</span> Woman(<span class="hljs-string">"Woman 2"</span>));

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>{
        <span class="hljs-keyword">public</span> String name;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Human</span><span class="hljs-params">(String name)</span> </span>{
            <span class="hljs-keyword">this</span>.name = name;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Man</span><span class="hljs-params">(String name)</span> </span>{
            <span class="hljs-keyword">super</span>(<span class="hljs-string">"Man:"</span> + name);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Woman</span><span class="hljs-params">(String name)</span> </span>{
            <span class="hljs-keyword">super</span>(<span class="hljs-string">"Woman:"</span> + name);
        }
    }
}

<span class="hljs-comment">// OUTPUT:</span>
<span class="hljs-comment">// Man Observer Type:Human</span>
<span class="hljs-comment">// Man Observer Type:Man</span>
<span class="hljs-comment">// Man Receive:Man:Man 1</span>
<span class="hljs-comment">// Man Observer Type:Woman</span>
<span class="hljs-comment">// Woman Observer Type:Human</span>
<span class="hljs-comment">// Man Observer Type:Human</span>
<span class="hljs-comment">// Woman Observer Type:Man</span>
<span class="hljs-comment">// Man Observer Type:Man</span>
<span class="hljs-comment">// Man Receive:Man:Man 2</span>
<span class="hljs-comment">// Woman Observer Type:Woman</span>
<span class="hljs-comment">// Woman Receive:Woman:Woman 2</span>
<span class="hljs-comment">// Man Observer Type:Woman</span>

</div></code></pre>
<p>后面加入的监听者无法收到前面已经下发的事件?如果后面加入的监听者要接收到最新下发的事件是不是就又要自己写代码了?如果后面加入的监听者要收到之前下发的所有事件是不是又要重新写代码?让 Observer 收到所有事件自己过滤要不要处理是不是不安全?</p>
<ul>
<li>Rxjava 的事件中心</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> io.reactivex.Observable;
<span class="hljs-keyword">import</span> io.reactivex.functions.Consumer;
<span class="hljs-keyword">import</span> io.reactivex.subjects.BehaviorSubject;
<span class="hljs-keyword">import</span> io.reactivex.subjects.PublishSubject;
<span class="hljs-keyword">import</span> io.reactivex.subjects.Subject;

<span class="hljs-comment">// 示例创建一个后添加的监听者也能接收到最近的一个事件的事件中心</span>
<span class="hljs-comment">// 并且事件的监听过滤收纳在 Observable 内部,不向外暴露.</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RxJavaEventCenter</span> </span>{

    <span class="hljs-keyword">static</span> Subject&lt;Human&gt; EVENT_CENTER = BehaviorSubject.create();

    <span class="hljs-keyword">static</span> Observable&lt;Human&gt; HUMAN_CENTER = EVENT_CENTER.ofType(Human<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">static</span> Observable&lt;Man&gt; MAN_CENTER = EVENT_CENTER.ofType(Man<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">static</span> Observable&lt;Woman&gt; WOMAN_CENTER = EVENT_CENTER.ofType(Woman<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        EVENT_CENTER.onNext(<span class="hljs-keyword">new</span> Human(<span class="hljs-string">"human 0"</span>));

        HUMAN_CENTER.subscribe(<span class="hljs-keyword">new</span> Consumer&lt;Human&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Human human)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                System.out.println(<span class="hljs-string">"Observer Human:"</span> + human.name);
            }
        });
        EVENT_CENTER.onNext(<span class="hljs-keyword">new</span> Human(<span class="hljs-string">"human 1"</span>));
        EVENT_CENTER.onNext(<span class="hljs-keyword">new</span> Man(<span class="hljs-string">"man 0"</span>));
        EVENT_CENTER.onNext(<span class="hljs-keyword">new</span> Man(<span class="hljs-string">"man 1"</span>));
        EVENT_CENTER.onNext(<span class="hljs-keyword">new</span> Woman(<span class="hljs-string">"woman 0"</span>));
        EVENT_CENTER.onNext(<span class="hljs-keyword">new</span> Man(<span class="hljs-string">"man 1"</span>));

        MAN_CENTER.subscribe(<span class="hljs-keyword">new</span> Consumer&lt;Man&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Man man)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                System.out.println(<span class="hljs-string">"Observer Man:"</span> + man.name);
            }
        });

        EVENT_CENTER.onNext(<span class="hljs-keyword">new</span> Man(<span class="hljs-string">"man 2"</span>));
<span class="hljs-comment">// 由于最近一个事件并非 Woman 因此该处订阅收不到任何事件</span>
        WOMAN_CENTER.subscribe(<span class="hljs-keyword">new</span> Consumer&lt;Woman&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Woman woman)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                System.out.println(<span class="hljs-string">"Observer Woman:"</span> + woman.name);
            }
        });
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>{
        <span class="hljs-keyword">public</span> String name;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Human</span><span class="hljs-params">(String name)</span> </span>{
            <span class="hljs-keyword">this</span>.name = name;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Man</span><span class="hljs-params">(String name)</span> </span>{
            <span class="hljs-keyword">super</span>(<span class="hljs-string">"Man:"</span> + name);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Woman</span><span class="hljs-params">(String name)</span> </span>{
            <span class="hljs-keyword">super</span>(<span class="hljs-string">"Woman:"</span> + name);
        }
    }
}

<span class="hljs-comment">//OUTPUT:</span>
<span class="hljs-comment">//Observer Human:human 0</span>
<span class="hljs-comment">//Observer Human:human 1</span>
<span class="hljs-comment">//Observer Human:Man:man 0</span>
<span class="hljs-comment">//Observer Human:Man:man 1</span>
<span class="hljs-comment">//Observer Human:Woman:woman 0</span>
<span class="hljs-comment">//Observer Human:Man:man 1</span>
<span class="hljs-comment">//Observer Man:Man:man 1</span>
<span class="hljs-comment">//Observer Human:Man:man 2</span>
<span class="hljs-comment">//Observer Man:Man:man 2</span>
</div></code></pre>
<ul>
<li>AsyncSubject</li>
</ul>
<p>订阅者只能接受 onComplete 之前的最新的一个事件,或者onError</p>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/AsyncSubject.png" alt="AsyncSubject"></p>
<ul>
<li>BehaviorSubject</li>
</ul>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/S.BehaviorSubject.png" alt="BehaviorSubject"></p>
<ul>
<li>CompletableSubject</li>
</ul>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/CompletableSubject.png" alt="CompletableSubject"></p>
<ul>
<li>MaybeSubject</li>
</ul>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MaybeSubject.png" alt="MaybeSubject"></p>
<ul>
<li>PublishSubject</li>
</ul>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/PublishSubject.png" alt="PublishSubject"></p>
<ul>
<li>ReplaySubject</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.ue.png" alt="ReplaySubject ERROR"></p>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.u.png" alt="ReplaySubject Normal"></p>
<ul>
<li>SerializedSubject</li>
</ul>
<p>只是为了 onXXX 串行化调用.</p>
<ul>
<li>SingleSubject</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/SingleSubject.png" alt="SingleSubject"></p>
<ul>
<li>UnicastSubject</li>
</ul>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastSubject.png" alt="UnicastSubject"></p>
<h3 id="%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97%E8%BD%AC%E6%8D%A2%E6%88%90%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97">异步事件序列转换成同步操作/异步任务转换成为异步事件序列</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> io.reactivex.Observable;
<span class="hljs-keyword">import</span> io.reactivex.ObservableEmitter;
<span class="hljs-keyword">import</span> io.reactivex.ObservableOnSubscribe;
<span class="hljs-keyword">import</span> io.reactivex.functions.Consumer;
<span class="hljs-keyword">import</span> io.reactivex.schedulers.Schedulers;

<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RxAsyncToSync</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
<span class="hljs-comment">//        异步的 Observable</span>
        Observable&lt;String&gt; one = Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                Thread.sleep(<span class="hljs-number">1000</span>);
                emitter.onNext(<span class="hljs-string">"one"</span>);
                emitter.onNext(<span class="hljs-string">"two"</span>);
                emitter.onComplete();
            }
        }).subscribeOn(Schedulers.io());
        System.out.println(<span class="hljs-string">"one async start subscribe @"</span>+System.currentTimeMillis());
        one.subscribe(<span class="hljs-keyword">new</span> Consumer&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                System.out.println(<span class="hljs-string">"one async onNext @"</span>+System.currentTimeMillis()+<span class="hljs-string">"Value:"</span>+s);
            }
        });
        System.out.println(<span class="hljs-string">"one async end subscribe @"</span>+System.currentTimeMillis());

<span class="hljs-comment">//        异步的 Observable 使其同步的返回数据</span>
        System.out.println(<span class="hljs-string">"one sync block start Get @"</span>+System.currentTimeMillis());
        List&lt;String&gt; blockingGet = one.toList().blockingGet();
        System.out.println(<span class="hljs-string">"one sync block end Get @"</span>+System.currentTimeMillis()+<span class="hljs-string">"Values:"</span>+ Arrays.deepToString(blockingGet.toArray()));

        Thread.sleep(<span class="hljs-number">3000</span>);
    }
<span class="hljs-comment">//    OUT_PUT:</span>
<span class="hljs-comment">//    one async start subscribe @1604025816577</span>
<span class="hljs-comment">//    one async end subscribe @1604025816596</span>
<span class="hljs-comment">//    one sync block start Get @1604025816596</span>
<span class="hljs-comment">//    one async onNext @1604025817613Value:one</span>
<span class="hljs-comment">//    one async onNext @1604025817613Value:two</span>
<span class="hljs-comment">//    one sync block end Get @1604025817630Values:[one, two]</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> io.reactivex.Observable;
<span class="hljs-keyword">import</span> io.reactivex.Observer;
<span class="hljs-keyword">import</span> io.reactivex.disposables.Disposable;
<span class="hljs-keyword">import</span> io.reactivex.functions.Consumer;
<span class="hljs-keyword">import</span> io.reactivex.schedulers.Schedulers;

<span class="hljs-keyword">import</span> java.util.concurrent.Callable;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.Future;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncToRxAsync</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService CACHED_EXECUTOR_SERVICE = Executors.newCachedThreadPool();


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        Future&lt;String&gt; future = CACHED_EXECUTOR_SERVICE.submit(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
                Thread.sleep(<span class="hljs-number">1000</span>);
<span class="hljs-comment">//                throw new IllegalArgumentException("args illegal!");</span>
                <span class="hljs-keyword">return</span> <span class="hljs-string">"callable return"</span>;
            }
        });
        System.out.println(<span class="hljs-string">"subscribe @:"</span> + System.currentTimeMillis());
        Observable.fromFuture(future, Schedulers.io())
                  .subscribe(<span class="hljs-keyword">new</span> Observer&lt;String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{

                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String s)</span> </span>{
                          System.out.println(<span class="hljs-string">"onNext @:"</span> + System.currentTimeMillis() + <span class="hljs-string">"Value:"</span> + s);
                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{
                          e.printStackTrace();
<span class="hljs-comment">//                          e.getCause().printStackTrace();</span>
                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{

                      }
                  });
    }

<span class="hljs-comment">//    OUT_PUT:</span>
<span class="hljs-comment">//    subscribe @:1604025972172</span>
<span class="hljs-comment">//    onNext @:1604025973184Value:callable return</span>
}
</div></code></pre>
<p>当然也可以将 RxAsync 转换成为 Future .只需要使用 Observable#toFuture</p>
<h3 id="%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E5%8F%8A%E6%97%B6%E5%8F%96%E6%B6%88">并发竞争/及时取消</h3>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="Observable#amb"></p>
<h3 id="%E9%98%B2%E6%8A%96">防抖</h3>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.png" alt="debounce"></p>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.png" alt="throttleFirst"></p>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.png" alt="throttleLast"></p>
<h2 id="rxjava-%E5%AE%9E%E6%88%98%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">rxjava 实战(函数式编程)</h2>
<h3 id="%E7%BC%93%E5%AD%98%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84%E5%8F%A0%E5%8A%A0%E6%95%B0%E5%AD%A6%E6%B1%82%E5%92%8C%E5%9D%87%E5%80%BC">缓存/过滤/分组/叠加/数学求和/均值/</h3>
<p>这些操作其实并非 rxjava 的核心目标,只是顺带实现了这些函数式编程已经提供的基础方法.需要引入rxjava 作者自己实现的扩展库<a href="https://github.com/akarnokd/RxJavaExtensions">https://github.com/akarnokd/RxJavaExtensions</a></p>
<h2 id="reactive-streams-%E8%A7%84%E8%8C%83%E6%8E%A5%E5%8F%A3">reactive-streams 规范接口</h2>
<p>Reactive Streams <a href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a> <a href="https://github.com/reactive-streams/reactive-streams-jvm">https://github.com/reactive-streams/reactive-streams-jvm</a></p>
<p>项目核心代码只定义了四个接口,但是大部分响应式编程的库都引用该库,遵守该接口规范.</p>
<h3 id="publisher">Publisher</h3>
<p>表示无限事件序列的生产者,rxjava2 中的 Flowable 实现了该接口,在 rxjava1 中没有实现该规范,因为该规范出现在 2014年1月(开始制定),而rxjava1则是从2012年3月开始开发的.</p>
<h3 id="subscriber">Subscriber</h3>
<p>表示事件的订阅者, Subscriber 通过 Publisher#subscribe 方法向生产者进行订阅. Publisher 则通过 Subscriber#onSubscribe,Subscriber#onNext,Subscriber#onError,Subscriber#onComplete 分别下发订阅关系,事件,error 状态,结束状态.</p>
<h3 id="subscription">Subscription</h3>
<p>表示订阅链的订阅关系.Subscriber 通过 Subscriber#onSubscribe 下发的 Subscription .通过 Subscription#cancel 可以取消订阅关系.通过 Subscription#request 消费者可以协调生产者的生产速率(如果生产者支持的话).</p>
<h3 id="processor">Processor</h3>
<p>同时继承了 Subscriber/Publisher,既是生产者也是消费者.</p>
<h2 id="rxjava-%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B">rxjava 基础组件简介</h2>
<h3 id="observable%E5%88%9B%E5%BB%BA%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85">Observable(创建/被观察者)</h3>
<p>0..N flows, no backpressure,</p>
<pre class="hljs"><code><div>        Observable.create(
                <span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;String&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        ObservableEmitter&lt;String&gt; serialize = emitter.serialize();
                        serialize.onNext(<span class="hljs-string">"one"</span>);
                        serialize.onNext(<span class="hljs-string">"two"</span>);
                        serialize.onNext(<span class="hljs-string">"three"</span>);
                        serialize.onComplete();
                    }
                })
</div></code></pre>
<pre class="hljs"><code><div>        Observable.just(<span class="hljs-string">"one"</span>)
                  .subscribe(<span class="hljs-keyword">new</span> Consumer&lt;String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                          System.out.println(<span class="hljs-string">"Accetp Data From ObservableEmitter:"</span> + s);
                      }
                  })
</div></code></pre>
<pre class="hljs"><code><div>String[] words = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Hi"</span>, <span class="hljs-string">"Aloha"</span>};
Observable observable = Observable.from(words);
<span class="hljs-comment">// 将会依次调用：</span>
<span class="hljs-comment">// onNext("Hello");</span>
<span class="hljs-comment">// onNext("Hi");</span>
<span class="hljs-comment">// onNext("Aloha");</span>
<span class="hljs-comment">// onCompleted();</span>
</div></code></pre>
<h3 id="subscriberobserver%E8%A7%82%E5%AF%9F%E8%80%85">Subscriber/Observer(观察者)</h3>
<p>均为含有订阅者/观察者的语义.</p>
<p>rxjava1 的 Subscriber 继承了 Subscription 因此还含有订阅关系的语义表示.</p>
<p>在 rxjava2 rxjava3 则保持相同的设计 Observer 只含有订阅者/观察者的语义.订阅关系的语义则由 Disposable 单独表述.移除了Subscriber 这个类.但是也新增了 DisposableObserver 这个类,用于表示 rxjava1 中的 Subscriber 语义.</p>
<p>选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<ul>
<li>
<p>onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。</p>
</li>
<li>
<p>unsubscribe()</p>
<p>这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>
<p>在 rxjava2 rxjava3 中则对应于 Disposable#dispose 和 Disposable#isDisposed 两个方法.</p>
</li>
</ul>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext()之外，还定义了两个特殊的事件：onCompleted() 和 onError()。</p>
<ul>
<li>
<p>onCompleted()</p>
<p>事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。</p>
</li>
<li>
<p>onError()</p>
<p>事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。</p>
</li>
</ul>
<p>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<ul>
<li>
<p>onSubscribe</p>
<p>rxjava2 添加在 Observer 中的方法,调用时会传入 Disposable 用于解除订阅关系 ,解决 rxjava1 同步订阅时无法取消的问题.</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> com.google.common.base.Ascii;
<span class="hljs-keyword">import</span> com.google.common.base.Strings;
<span class="hljs-keyword">import</span> com.google.common.collect.Lists;
<span class="hljs-keyword">import</span> io.reactivex.*;
<span class="hljs-keyword">import</span> io.reactivex.disposables.Disposable;
<span class="hljs-keyword">import</span> io.reactivex.functions.BiFunction;
<span class="hljs-keyword">import</span> io.reactivex.functions.Consumer;
<span class="hljs-keyword">import</span> io.reactivex.functions.Function;
<span class="hljs-keyword">import</span> io.reactivex.schedulers.Schedulers;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateObservable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        Observable.create(
                <span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;String&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        ObservableEmitter&lt;String&gt; serialize = emitter.serialize();
                        serialize.onNext(<span class="hljs-string">"one"</span>);
                        serialize.onNext(<span class="hljs-string">"two"</span>);
                        serialize.onNext(<span class="hljs-string">"three"</span>);
                        serialize.onComplete();
                    }
                })
<span class="hljs-comment">//                  小写变大写</span>
                  .map(<span class="hljs-keyword">new</span> Function&lt;String, String&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                          <span class="hljs-keyword">return</span> Ascii.toUpperCase(s);
                      }
                  })
<span class="hljs-comment">//                  String 流变 char 流</span>
                  .flatMap(<span class="hljs-keyword">new</span> Function&lt;String, Observable&lt;Character&gt;&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;Character&gt; <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                          <span class="hljs-keyword">return</span> Observable.fromIterable(Lists.charactersOf(s));
                      }
                  })
<span class="hljs-comment">//                  char 流去重 ONETWHR</span>
                  .distinct()
<span class="hljs-comment">//                  再排序 E H N O R T W</span>
                  .sorted()
                  .subscribeOn(Schedulers.io())
                  .subscribe(<span class="hljs-keyword">new</span> Observer&lt;Character&gt;() {
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{

                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Character character)</span> </span>{
                          System.out.println(character);
                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{

                      }

                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{

                      }
                  });
        Thread.sleep(<span class="hljs-number">1000</span>);
    }
}
<span class="hljs-comment">// OUT_PUT:</span>
<span class="hljs-comment">// E</span>
<span class="hljs-comment">// H</span>
<span class="hljs-comment">// N</span>
<span class="hljs-comment">// O</span>
<span class="hljs-comment">// R</span>
<span class="hljs-comment">// T</span>
<span class="hljs-comment">// W</span>

</div></code></pre>
<p><img src="rxjavaimg/rxjava事件流概括.png" alt="rxjava 事件流">
<img src="rxjavaimg/rxjava订阅执行流程.png" alt="rxjava 订阅流程"></p>
<p><img src="rxjavaimg/map.jpg" alt="Map示意图"></p>
<p><img src="rxjavaimg/flatmap.jpg" alt="FlatMap 示意图"></p>
<p>图中的 OnSubscribe 为 rxjava1 的遗留概念,rxjava2 中不存在.对应的功能被合并进入了 Observable#subscribeActual.有兴趣的可以对比一下 rxjava1 rxjava2 中 Observable#just 操作附的实现.</p>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/map.png" alt="Observable#map"></p>
<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png" alt="Observable#flatMap"></p>
<h3 id="subscriptiondisposable%E8%AE%A2%E9%98%85%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB">Subscription/Disposable(订阅/订阅关系)</h3>
<p>rxjava1 中 Observable#subscribe 订阅方法的返回值则为 Subscription 订阅关系.</p>
<p>rxjava2/rxjava3 中 Observable#subscribe 的订阅者如果为 Observer 则该订阅方法的返回值为 void,订阅关系的描述 Disposable 则通过 Observer#onSubscribe 下发进入 Observer 内部用于取消订阅关系.</p>
<p>订阅关系取消的条件有两种:</p>
<ul>
<li>
<p>Observer 认为自己不需要再关注 Observable 下发的事件了,调用 Subscription#unsubscribe 或者 Disposable#dispose</p>
</li>
<li>
<p>Observable 认为自己不再发送数据了即数据已经发送完毕,或者在数据的产生过程/处理过程中出现了未捕获的异常.则会分别调用 Observer#onComplete 或 Observer#onError 同时解除订阅关系.</p>
</li>
</ul>
<p>订阅关系在不再需要时需要及时取消,否则会占用资源.</p>
<h3 id="scheduler">Scheduler</h3>
<p>传递给 Observable#observeOn,Observable#subscribeOn 的线程任务调度器用于切换订阅者观察者的执行线程.</p>
<p>内置线程调度器分为:</p>
<ul>
<li>
<p>IO</p>
<p>底层为线程池的线程最大数量设置为 int 的最大值.</p>
</li>
<li>
<p>COMPUTATION</p>
<p>底层为根据 cpu 核心数配置的固定线程数的线程池.</p>
</li>
<li>
<p>SINGLE</p>
<p>底层为只有一个线程的线程池</p>
</li>
<li>
<p>TRAMPOLINE</p>
<p>蹦床模式,在当前线程执行该任务但是并不是立即执行,会稍后执行.实现为使当前线程会进入事件循环模式.</p>
</li>
<li>
<p>NEW_THREAD</p>
<p>每次调度任务执行都新建一个线程执行.</p>
</li>
<li>
<p>MAIN</p>
<p>客户端的特殊的主线程</p>
</li>
</ul>
<h3 id="flowable">Flowable</h3>
<p>0..N flows, supporting Reactive-Streams and backpressure</p>
<p>rxjava1 中不存在</p>
<h3 id="single">Single</h3>
<p>a flow of exactly 1 item or an error,</p>
<h3 id="maybe">Maybe</h3>
<p>a flow with no items, exactly one item or an error.</p>
<p>rxjava1 中不存在.</p>
<h3 id="completable">Completable</h3>
<p>a flow without items but only a completion or error signal,</p>
<h3 id="subject">Subject</h3>
<p>既是 Observable 也是 Observer.其实可以理解为事件中转站,自己作为 Observer 接收上游下发的事件,同时自己也作为 Observable 可以被订阅,向订阅了自己的订阅者下发之前接收到的事件.</p>
<h3 id="subscribeonobserveon">subscribeOn/observeOn</h3>
<ul>
<li>
<p>subscribeOn</p>
<p>切换 subscribe 操作的线程.</p>
</li>
<li>
<p>observeOn</p>
<p>切换响应者的线程.</p>
</li>
</ul>
<h3 id="flowableobservablesinglemaybecompletable">Flowable/Observable/Single/Maybe/Completable</h3>
<p>是可以相互转换的,产生的事件序列依次从多到少.</p>
<h2 id="%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5">高级概念</h2>
<h3 id="%E8%83%8C%E5%8E%8B">背压</h3>
<p>生产者的生产效率大于消费者的消费效率.因此需要配置仓库容纳生产者生产的产品,或者直接按照配置的规则丢弃生产者生产的产品,再或者要求生产者放慢生产效率,按照需求生产产品.如果一直存储则会最终打爆内存导致崩溃.</p>
<p>rxjava1:在创建安全 Observable 时则要求传入背压策略进行背压控制.</p>
<p>rxjava2:Observable 不再支持背压控制策略语义,创建安全 Observable 时使用串行发射器默认的背压策略时无限缓存.只有创建 Flowable 时才会要求和可以进行背压策略控制.rxjava1 中不存在 Flowable 的概念.
<em>如果不需要串行化调用 onNext 方法,则不存在背压的问题</em></p>
<h3 id="%E4%B8%B2%E8%A1%8C%E8%AE%BF%E9%97%AE">串行访问</h3>
<p>Observer#onNext/Observer#onComplete/Observer#onError 的串行化访问</p>
<p>rxjava1:</p>
<p>创建自定义的Observable分为两种:Observable#unsafeCreate和Observable#create,前者是不保证串行访问的,后者则会保证串行访问.同时前者也不保证 onError 和 onCompleted 只能被调用一次,当 onError 和 onComplete 被调用之后不能再调用 onNext 的语义规则.</p>
<p>rxjava2,rxjava3:</p>
<p>Observable#create 创建的 Observable 不再保证串行化访问.如果需要串行化访问则需要使用 ObservableEmitter#serialize 获得串行化发射器,使用串行化发射器才能保证下游数据的串行访问. Observable 不提供串行访问也就不存在背压问题.一旦串行化之后内部便会提供一个SPSC 队列用于缓存来不及消费的元素.</p>
<p><em>队列漏和发射循环是实现串行化访问语义的基础算法.</em></p>
<h3 id="%E5%86%B7%E7%83%AD-observable">冷/热 Observable</h3>
<p>冷: 每次订阅都产生事件序列,只在有订阅者的时候产生事件序列.每次产生的事件序列可能相同也可能不同,与作者的实现有关.</p>
<p>热: 不管有没有订阅者都按照既定的规则产生事件序列,可以被多次订阅,但后面的订阅者无法收到前面已经错过的事件序列.主要使用在不想订阅者订阅一次就要求执行一次操作的场景,避免过多的资源耗费.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.github.hunter524.rxjava.start;

<span class="hljs-keyword">import</span> io.reactivex.Observable;
<span class="hljs-keyword">import</span> io.reactivex.ObservableEmitter;
<span class="hljs-keyword">import</span> io.reactivex.ObservableOnSubscribe;
<span class="hljs-keyword">import</span> io.reactivex.Observer;
<span class="hljs-keyword">import</span> io.reactivex.disposables.Disposable;
<span class="hljs-keyword">import</span> io.reactivex.observables.ConnectableObservable;
<span class="hljs-keyword">import</span> io.reactivex.schedulers.Schedulers;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotColdObservable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        Observable&lt;String&gt; coldOb = Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                emitter.onNext(<span class="hljs-string">"1-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
                emitter.onNext(<span class="hljs-string">"2-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
                emitter.onNext(<span class="hljs-string">"3-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
                emitter.onNext(<span class="hljs-string">"4-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
            }
        });

        Observable&lt;String&gt; hotOb = Observable
                .create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;String&gt;() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                        emitter.onNext(<span class="hljs-string">"1-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
                        Thread.sleep(<span class="hljs-number">1000</span>);
                        emitter.onNext(<span class="hljs-string">"2-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
                        Thread.sleep(<span class="hljs-number">1000</span>);
                        emitter.onNext(<span class="hljs-string">"3-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
                        Thread.sleep(<span class="hljs-number">1000</span>);
                        emitter.onNext(<span class="hljs-string">"4-"</span>+<span class="hljs-string">"TIME:"</span>+System.nanoTime());
                    }
                })
                .subscribeOn(Schedulers.io())
                .publish();

        ((ConnectableObservable&lt;String&gt;) hotOb).connect();


        coldOb.subscribe(<span class="hljs-keyword">new</span> Observer&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String s)</span> </span>{
                System.out.println(<span class="hljs-string">"cold subscribe 1 ====:"</span>+s);
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{

            }
        });

        coldOb.subscribe(<span class="hljs-keyword">new</span> Observer&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String s)</span> </span>{
                System.out.println(<span class="hljs-string">"cold subscribe 2====:"</span>+s);
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{

            }
        });

        Thread.sleep(<span class="hljs-number">1100</span>);

        hotOb.subscribe(<span class="hljs-keyword">new</span> Observer&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String s)</span> </span>{
                System.out.println(<span class="hljs-string">"hot subscribe 1 ====:"</span>+s);
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{

            }
        });
        Thread.sleep(<span class="hljs-number">1100</span>);

        hotOb.subscribe(<span class="hljs-keyword">new</span> Observer&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String s)</span> </span>{
                System.out.println(<span class="hljs-string">"hot subscribe 2 ====:"</span>+s);
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>{

            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>{

            }
        });
        Thread.sleep(<span class="hljs-number">5000</span>);
    }
<span class="hljs-comment">//    OUT_PUT</span>
<span class="hljs-comment">//    cold subscribe 1 ====:1-TIME:39156321281444</span>
<span class="hljs-comment">//    cold subscribe 1 ====:2-TIME:39156321810264</span>
<span class="hljs-comment">//    cold subscribe 1 ====:3-TIME:39156321970437</span>
<span class="hljs-comment">//    cold subscribe 1 ====:4-TIME:39156322094173</span>

<span class="hljs-comment">//    cold subscribe 2====:1-TIME:39156322506015</span>
<span class="hljs-comment">//    cold subscribe 2====:2-TIME:39156322684361</span>
<span class="hljs-comment">//    cold subscribe 2====:3-TIME:39156322796437</span>
<span class="hljs-comment">//    cold subscribe 2====:4-TIME:39156322914416</span>

<span class="hljs-comment">//    hot subscribe 1 ====:3-TIME:39158324861822</span>
<span class="hljs-comment">//    hot subscribe 1 ====:4-TIME:39159325097997</span>

<span class="hljs-comment">//    hot subscribe 2 ====:4-TIME:39159325097997</span>
}
</div></code></pre>
<h3 id="operatorobservableliftobservabletransformerobservablecompose">Operator/Observable#lift/ObservableTransformer/Observable#compose</h3>
<p>rxjava1 遗留的概念,在 rxjava1 中很多内置操作符语义都是通过 Operator 和 Observable#lift 进行实现的.有点复杂不够直观.
前者用来转换 Observer 后者用来转换 Observable.</p>
<p>rxjava2 和 rxjava3 中则不再使用 Operator 实现内置的操作符语义.转而使用包装 Observable 和 Observer 实现操作符语义.提供给用户使用 Observable#as 操作符进行 Observable 的包装.[Uber AutoDispose][https://uber.github.io/AutoDispose/] 则是基于该操作符进行的扩展,从而实现根据生命周期自动解除订阅的功能.</p>
<h3 id="producer">Producer</h3>
<p>rxjava1 遗留的概念,用于消费者协调生产者的生产效率,解决背压问题. rxjava2 中只有 Flowable 流中存在对应的概念.但是已经不是像 rxjava1 中使用自己定义的 Producer 而是使用 org.reactivestreams 规范中定义的 Subscription 接口.</p>
<h3 id="rxjavahooksrxjavaplugins-%E6%9C%BA%E5%88%B6">RxJavaHooks/RxJavaPlugins 机制</h3>
<p>人工提供的切面,可以在事件下发,onError回调,线程调度提供了一个监控和替换的切面.</p>
<h3 id="%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0">响应式编程的定义/实现</h3>
<ul>
<li>
<p>社区界的接口定义/规范定义 <a href="https://github.com/reactive-streams/">https://github.com/reactive-streams/</a></p>
</li>
<li>
<p>规范官网 <a href="https://www.reactive-streams.org/">https://www.reactive-streams.org/</a></p>
</li>
<li>
<p>主流的各种语言的实现 <a href="https://github.com/ReactiveX">https://github.com/ReactiveX</a> 其中 rxjava 43.6k 个 star.rxjs 23.2k 个 star.</p>
</li>
<li>
<p>Spring 也支持响应试编程 <a href="https://spring.io/reactive">https://spring.io/reactive</a> 只不过其推荐了另外一种实现方式<a href="https://github.com/reactor/">https://github.com/reactor/</a>作为其生态的一部分。但是其也实现了 reactive-streams 规范.</p>
</li>
<li>
<p>jdk 9 增加了 flow 响应式编程的支持 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Publisher.html">https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Publisher.html</a></p>
</li>
</ul>
<h3 id="%E8%B0%81%E5%9C%A8%E4%BD%BF%E7%94%A8">谁在使用</h3>
<p>reactivex 官网下滑 <a href="http://reactivex.io">http://reactivex.io</a></p>
<h3 id="reference">Reference</h3>
<ul>
<li>
<p>扔物线的 rxjava 入门教程 <a href="https://gank.io/post/560e15be2dca930e00da1083">https://gank.io/post/560e15be2dca930e00da1083</a> <em>本人入门时看的第一篇教程</em></p>
</li>
<li>
<p>rxjava1 源码分析 <a href="https://blog.piasy.com/AdvancedRxJava/index.html">https://blog.piasy.com/AdvancedRxJava/index.html</a> <em>阅读 rxjava 源码是参考的系列文章,读懂了 rxjava1 的源码 rxjava2 rxjava3 的源码根本不存在问题,因为 rxjava1 的实现机制更复杂,不够简洁</em></p>
</li>
<li>
<p>串行访问,非阻塞算法 (emitter-loop)发射循环<a href="https://blog.piasy.com/AdvancedRxJava/2016/05/06/operator-concurrency-primitives/index.html">https://blog.piasy.com/AdvancedRxJava/2016/05/06/operator-concurrency-primitives/index.html</a></p>
</li>
<li>
<p>串行访问,非阻塞算法 (queue-drain)队列漏]<a href="https://blog.piasy.com/AdvancedRxJava/2016/05/13/operator-concurrency-primitives-2/index.html">https://blog.piasy.com/AdvancedRxJava/2016/05/13/operator-concurrency-primitives-2/index.html</a></p>
</li>
<li>
<p>JCTools Java Concurrent Tools <a href="https://github.com/JCTools/JCTools">https://github.com/JCTools/JCTools</a></p>
</li>
<li>
<p>rxjava 函数式扩展 <a href="https://github.com/akarnokd/RxJavaExtensions">https://github.com/akarnokd/RxJavaExtensions</a></p>
</li>
<li>
<p>rxjava 操作附汇总 <a href="https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators">https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators</a></p>
</li>
<li>
<p>rxjava 发起者,akarnokd 匈牙利,布达佩斯 匈牙利科学院的工程学博士<a href="https://akarnokd.blogspot.com/">https://akarnokd.blogspot.com/</a>作者只主写了 rxjava. 其他语言的版本均由开源社区的其他人员创作.其也是 reactive-streams 规范的制定者之一.</p>
</li>
</ul>

</body>
</html>
